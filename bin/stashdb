#!/usr/bin/env python3
"""
╔══════════════════════════════════════════════════════════════════════════════╗
║                        BPP Database Stashing Tool                            ║
║                      Time-travel for your databases                          ║
╚══════════════════════════════════════════════════════════════════════════════╝

STASHDB - Because sometimes you need a safety net when working with databases.

This tool provides Git-like stash functionality for PostgreSQL databases,
letting you save snapshots with automatic timestamping and effortlessly restore
them later. Perfect for development, testing, and "oh no" moments.

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

COMMANDS:

  save          📦  Stash away your current 'bpp' database
                    Creates a timestamped snapshot with institution code

  restore       ♻️   Bring back a stashed database
                    Restores the most recent snapshot for a given institution

  list          📋  Browse your database stash
                    Shows all available snapshots, organized by institution

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

EXAMPLES:

  # Save current database
  $ stashdb save

  # List all stashed databases
  $ stashdb list

  # List stashes for specific institution
  $ stashdb list UPMED

  # Restore most recent UPMED database
  $ stashdb restore UPMED

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

ENVIRONMENT:

  PostgreSQL connection parameters can be configured via:
    PGHOST, PGPORT, PGUSER, PGPASSWORD

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

HOW IT WORKS:

Databases are renamed (not copied) using this pattern:
  bpp_{institution_code}_{timestamp}

The timestamp is extracted from your database records (bpp_rekord_mat table),
ensuring consistent snapshots that reflect actual data state.

When restoring, your current 'bpp' database is automatically backed up as
'bpp_old_{timestamp}' before the restore happens - safety first!

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

Copyright (c) 2025-2026 iplweb
Licensed under MIT License
https://iplweb.pl
"""

import argparse
import re
import subprocess
import sys
from datetime import datetime


# ANSI color codes
class Colors:
    RED = "\033[0;31m"
    GREEN = "\033[0;32m"
    YELLOW = "\033[1;33m"
    CYAN = "\033[0;36m"
    NC = "\033[0m"  # No Color


def error(message: str) -> None:
    """Print error message to stderr and exit."""
    print(f"{Colors.RED}Error: {message}{Colors.NC}", file=sys.stderr)
    sys.exit(1)


def success(message: str) -> None:
    """Print success message."""
    print(f"{Colors.GREEN}{message}{Colors.NC}")


def info(message: str) -> None:
    """Print info message."""
    print(f"{Colors.YELLOW}{message}{Colors.NC}")


def heading(message: str) -> None:
    """Print heading message."""
    print(f"{Colors.CYAN}{message}{Colors.NC}")


def run_psql(database: str, command: str, expect_output: bool = False) -> str | None:
    """
    Execute a PostgreSQL command using psql.

    Args:
        database: Database name to connect to
        command: SQL command to execute
        expect_output: Whether to return command output

    Returns:
        Command output if expect_output is True, None otherwise
    """
    cmd = ["psql", "-d", database]

    if expect_output:
        cmd.extend(["-A", "-t"])  # Aligned output, tuples only (no headers)

    cmd.extend(["-c", command])

    try:
        result = subprocess.run(cmd, capture_output=True, text=True, check=True)
        if expect_output:
            return result.stdout.strip()
        return None
    except subprocess.CalledProcessError as e:
        error(f"PostgreSQL command failed: {e.stderr}")
    except FileNotFoundError:
        error("psql command not found. Please ensure PostgreSQL client is installed.")


def database_exists(dbname: str) -> bool:
    """Check if a database exists."""
    result = run_psql(
        "postgres",
        f"SELECT 1 FROM pg_database WHERE datname = '{dbname}';",
        expect_output=True,
    )
    return bool(result and result.strip())


def terminate_connections(dbname: str) -> None:
    """Terminate all connections to a database."""
    print(f"Terminating existing connections to {dbname}...")
    run_psql(
        "postgres",
        f"SELECT pg_terminate_backend(pid) FROM pg_stat_activity "
        f"WHERE datname = '{dbname}' AND pid <> pg_backend_pid();",
    )


def get_databases_matching(pattern: str) -> list[str]:
    """Get list of databases matching a LIKE pattern."""
    result = run_psql(
        "postgres",
        f"SELECT datname FROM pg_database WHERE datname LIKE '{pattern}' ORDER BY datname;",
        expect_output=True,
    )
    if not result:
        return []
    return [db.strip() for db in result.split("\n") if db.strip()]


def validate_identifier(value: str, name: str) -> None:
    """Validate that a string contains only alphanumeric characters and underscores."""
    if not re.match(r"^[a-zA-Z0-9_]+$", value):
        error(f"{name} must contain only alphanumeric characters and underscores")


def cmd_save(args) -> None:
    """Save (stash) the current 'bpp' database."""
    source_db = "bpp"

    # Check if source database exists
    if not database_exists(source_db):
        error(f"Database '{source_db}' does not exist")

    # Query the database for skrot and timestamp
    info("Querying database for stash parameters...")
    query = (
        "SELECT "
        "(SELECT skrot FROM bpp_uczelnia LIMIT 1), "
        "COALESCE(to_char(MAX(ostatnio_zmieniony), 'YYYYMMDDHH24MISS'), "
        "to_char(NOW(), 'YYYYMMDDHH24MISS')) "
        "FROM bpp_rekord_mat;"
    )
    result = run_psql(source_db, query, expect_output=True)

    if not result or "|" not in result:
        error(
            "Could not query skrot from bpp_uczelnia or ostatnio_zmieniony from bpp_rekord_mat"
        )

    parts = result.split("|")
    skrot = parts[0].strip()
    timestamp = parts[1].strip()

    if not skrot or not timestamp:
        error(
            "Could not query skrot from bpp_uczelnia or ostatnio_zmieniony from bpp_rekord_mat"
        )

    # Replace spaces with underscores in skrot for database name
    skrot_normalized = skrot.replace(" ", "_")
    target_db = f"bpp_{skrot_normalized}_{timestamp}"

    print(f"  Skrot: {skrot}")
    if skrot != skrot_normalized:
        print(f"  Normalized: {skrot_normalized} (spaces replaced with underscores)")
    print(f"  Timestamp: {timestamp}")
    print()

    info("Stashing database...")
    print(f"  Source: {source_db}")
    print(f"  Target: {target_db}")
    print()

    # Check if target database already exists
    if database_exists(target_db):
        error(f"Database '{target_db}' already exists")

    # Terminate existing connections to the source database
    terminate_connections(source_db)

    # Rename the database
    print("Renaming database...")
    run_psql("postgres", f'ALTER DATABASE "{source_db}" RENAME TO "{target_db}";')

    success(f"Success! Database renamed: {source_db} -> {target_db}")


def show_available_databases_grouped() -> None:
    """Show all available stashed databases grouped by institution code."""
    databases = get_databases_matching("bpp_%")
    if not databases:
        print("No stashed databases found.")
        return

    # Group databases by skrot (extract skrot from bpp_{skrot}_{timestamp})
    skrots = {}
    for db in databases:
        match = re.match(r"bpp_([^_]+)_", db)
        if match:
            s = match.group(1)
            if s not in skrots:
                skrots[s] = []
            skrots[s].append(db)

    heading("Available stashed databases:")
    print()
    for s in sorted(skrots.keys()):
        print(f"{Colors.YELLOW}Skrot: {s}{Colors.NC}")
        for db in skrots[s]:
            print(f"  {Colors.GREEN}{db}{Colors.NC}")
        print()

    print(f"Use: {sys.argv[0]} restore <skrot>")


def backup_existing_database(target_db: str) -> None:
    """Backup existing target database before restoring."""
    current_timestamp = datetime.now().strftime("%Y%m%d%H%M%S")
    backup_db = f"bpp_old_{current_timestamp}"
    info(f"Database '{target_db}' exists. Renaming to '{backup_db}' first...")

    # Check if backup database name already exists
    counter = 1
    original_backup_db = backup_db
    while database_exists(backup_db):
        backup_db = f"{original_backup_db}_{counter}"
        counter += 1

    # Terminate existing connections to the target database
    terminate_connections(target_db)

    # Rename existing bpp database
    run_psql("postgres", f'ALTER DATABASE "{target_db}" RENAME TO "{backup_db}";')
    success(f"Existing database saved as: {backup_db}")
    print()


def cmd_restore(args) -> None:
    """Restore a stashed database to 'bpp'."""
    skrot = args.skrot

    # If no skrot provided, list available databases grouped by skrot
    if not skrot:
        show_available_databases_grouped()
        return

    # Validate skrot
    validate_identifier(skrot, "Skrot")

    target_db = "bpp"
    pattern = f"bpp_{skrot}_%"

    # Find the most recent database matching the pattern
    databases = get_databases_matching(pattern)

    if not databases:
        error(
            f"No database found matching pattern '{pattern}'\n\n"
            f"Use '{sys.argv[0]} list {skrot}' to see available databases"
        )

    # Get the most recent (last when sorted)
    source_db = databases[-1]

    info("Restoring database...")
    print(f"  Source: {source_db}")
    print(f"  Target: {target_db}")
    print()

    # Check if target database exists and backup if needed
    if database_exists(target_db):
        backup_existing_database(target_db)

    # Terminate existing connections to the source database
    terminate_connections(source_db)

    # Rename the source database to bpp
    print("Restoring database...")
    run_psql("postgres", f'ALTER DATABASE "{source_db}" RENAME TO "{target_db}";')

    success(f"Success! Database restored: {source_db} -> {target_db}")


def cmd_list(args) -> None:
    """List available stashed databases."""
    skrot = args.skrot

    if skrot:
        validate_identifier(skrot, "Skrot")
        pattern = f"bpp_{skrot}_%"
        label_text = f"databases with skrot '{skrot}'"
    else:
        pattern = "bpp_%"
        label_text = "all stashed databases"

    heading(f"Listing {label_text}...")
    print()

    databases = get_databases_matching(pattern)

    if not databases:
        print(f"No databases found matching pattern: {pattern}")
        return

    for db in databases:
        print(f"  {Colors.GREEN}{db}{Colors.NC}")

    print()
    info(f"Total: {len(databases)} database(s)")


def main():
    """Main entry point."""
    parser = argparse.ArgumentParser(
        description="📦 STASHDB - Time-travel for your BPP databases",
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog=__doc__,
    )

    subparsers = parser.add_subparsers(dest="command", help="Available commands")

    # Save command
    parser_save = subparsers.add_parser(
        "save",
        help="📦 Stash away your current database with automatic timestamping",
        description="Creates a timestamped snapshot of the 'bpp' database. "
        "The database is renamed (not copied) using the pattern: "
        "bpp_{institution_code}_{timestamp}",
    )
    parser_save.set_defaults(func=cmd_save)

    # Restore command
    parser_restore = subparsers.add_parser(
        "restore",
        help="♻️  Bring back a stashed database (most recent snapshot)",
        description="Restores the most recent stashed database for a given institution. "
        "Your current 'bpp' database is automatically backed up before restoration.",
    )
    parser_restore.add_argument(
        "skrot",
        nargs="?",
        help="Institution code (skrot/abbreviation). "
        "If not provided, lists all available stashed databases grouped by institution.",
    )
    parser_restore.set_defaults(func=cmd_restore)

    # List command
    parser_list = subparsers.add_parser(
        "list",
        help="📋 Browse your database stash",
        description="Lists all available stashed databases. "
        "Can be filtered by institution code to show only specific snapshots.",
    )
    parser_list.add_argument(
        "skrot",
        nargs="?",
        help="Optional institution code. Filter to show only databases with this skrot.",
    )
    parser_list.set_defaults(func=cmd_list)

    args = parser.parse_args()

    if not args.command:
        parser.print_help()
        sys.exit(1)

    args.func(args)


if __name__ == "__main__":
    main()
